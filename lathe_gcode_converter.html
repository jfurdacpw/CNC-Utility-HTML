<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lathe G-code Converter (V/W → D + rotQty)</title>
  <style>
    :root { color-scheme: light dark; }
    *, *::before, *::after { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 6px; }
    .wrap { max-width: 1200px; margin: 0 auto; display: grid; gap: 6px; }
    .bar { display: flex; flex-wrap: wrap; gap: 8px; align-items: end; }
    .card { border: 1px solid rgba(127,127,127,.35); border-radius: 8px; padding: 6px 8px; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
    .grid .card { min-width: 0; }
    textarea { box-sizing: border-box; width: 100%; min-height: 120px; height: 120px; resize: vertical; border-radius: 6px; border: 1px solid rgba(127,127,127,.35); padding: 6px 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 11px; line-height: 1.3; }
    label { display: grid; gap: 2px; font-size: 12px; }
    input, select, button { font-size: 13px; }
    input, select { border-radius: 6px; border: 1px solid rgba(127,127,127,.35); padding: 4px 6px; }
    button { border-radius: 6px; border: 1px solid rgba(127,127,127,.35); padding: 5px 8px; cursor: pointer; }
    button.primary { font-weight: 650; }
    .hint { opacity: .85; font-size: 11px; line-height: 1.25; }
    .pill { display:inline-flex; flex-wrap:wrap; gap:6px; align-items:center; padding:4px 8px; border-radius: 999px; border: 1px solid rgba(127,127,127,.35); font-size: 11px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .field-row { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 6px 10px; align-items: end; }
    .field-row .full { grid-column: 1 / -1; }
    .field-group { display: flex; flex-wrap: wrap; gap: 6px 8px; align-items: end; }
    .start-pos { background: rgba(0,180,0,.12); }
    .final-pos { background: rgba(220,0,0,.12); }
    .card-title { font-weight: 650; margin-bottom: 4px; font-size: 13px; }
    .toolpath-wrap { position: relative; width: 100%; min-height: 280px; background: var(--toolpath-bg, #1a1a1a); border-radius: 6px; }
    .toolpath-wrap canvas { display: block; width: 100%; height: 100%; }
    .view-label { position: absolute; font-size: 10px; opacity: 0.9; pointer-events: none; color: #00d4aa; }
    @media (prefers-color-scheme: light) { .view-label { color: #0a6b5a; } }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div style="display:flex; flex-wrap:wrap; gap:6px; align-items:center; justify-content:space-between;">
        <div>
          <div style="font-size:15px; font-weight:700;">Lathe G-code Converter</div>
          <div class="hint">Accepts <span class="mono">U</span>/<span class="mono">V</span>/<span class="mono">W</span> or <span class="mono">X</span>,<span class="mono">Z</span>,<span class="mono">A</span>. Appends <span class="mono">D</span> + <span class="mono">;rotQty=</span> (FileMaker-compatible).</div>
        </div>
        <div class="pill"><span>Formula:</span> <span class="mono">segment = √((ΔX)²+(ΔY)²+(ΔZ)²)</span> or <span class="mono">√((ΔU)²+(ΔW)²)</span>/<span class="mono">√((ΔV)²+(ΔW)²)</span>; missing axis = 0 · <span class="mono">rotQty = segment ÷ passWidth</span> · <span class="mono">ΔD = rotQty × 360</span> (D cumulative)</div>
      </div>
    </div>

    <div class="card">
      <div class="card-title">Program details</div>
      <div class="field-row">
        <label><span class="mono">programID</span><input id="programID" type="text" /></label>
        <label><span class="mono">operationID</span><input id="operationID" type="text" /></label>
        <label><span class="mono">translation</span><input id="translation" type="text" placeholder="e.g. Spun Lathe Part" /></label>
        <label><span class="mono">lineNumberType</span><input id="lineNumberType" type="text" value="N" placeholder="N" /></label>
        <label><span class="mono">passWidth</span><input id="passWidth" type="number" step="0.01" value="0.5" /></label>
        <label class="full"><span class="mono">programName</span><input id="programName" type="text" placeholder="Program name" style="width:100%;" /></label>
        <label class="full"><span class="mono">description</span><input id="description" type="text" placeholder="Optional description" /></label>
      </div>
    </div>

    <div class="card">
      <div class="card-title">Conversion parameters</div>
      <div class="field-group">
        <label style="min-width:120px;"><span class="mono">partDiameter</span><input id="partDiameter" type="number" step="0.01" value="1.25" /></label>
        <label style="min-width:120px;"><span class="mono">travelSpeedF</span><input id="travelSpeedF" type="number" step="0.1" value="25" readonly title="Calculated: passWidth × desiredSurfaceSpeed ÷ (partDiameter × π)" /></label>
        <label style="min-width:140px;"><span class="mono">desiredSurfaceSpeed</span><input id="desiredSurfaceSpeed" type="number" step="0.1" value="200" /></label>
        <label style="min-width:160px;"><span class="mono">startingLathePosition</span><input id="startD" class="start-pos" type="number" step="0.00001" value="0" /></label>
        <label style="min-width:160px;"><span class="mono">finalLathePosition</span><input id="finalLathePosition" class="final-pos" type="number" step="0.00001" value="" readonly placeholder="Set after convert" /></label>
      </div>
      <div style="display:flex; gap:6px; flex-wrap:wrap; align-items:center; margin-top:6px;">
        <button class="primary" id="btnConvert">Convert</button>
        <button id="btnCopy">Copy output</button>
        <button id="btnDownload">Download .nc</button>
        <span class="hint" id="status"></span>
      </div>
      <div class="hint" style="margin-top:4px;"><span class="mono">travelSpeedF</span> = Round(passWidth × desiredSurfaceSpeed ÷ (partDiameter × π), 0).</div>
    </div>


    <div class="grid">
      <div class="card">
        <div class="card-title">Input</div>
        <textarea id="input" placeholder="Paste G-code here..."></textarea>
      </div>

      <div class="card">
        <div class="card-title">Output</div>
        <textarea id="output" placeholder="Converted output..." readonly></textarea>
      </div>
    </div>

    <div class="card">
      <div class="card-title">Toolpath</div>
      <div class="toolpath-wrap">
        <canvas id="toolpath" style="max-height: 320px; width: 100%; display: block;"></canvas>
        <span class="view-label" id="viewTop" style="top: 6px; left: 8px;">Top</span>
        <span class="view-label" id="viewIso" style="top: 6px; right: 8px;">Iso</span>
        <span class="view-label" id="viewFront" style="bottom: 6px; left: 8px;">Front</span>
        <span class="view-label" id="viewRight" style="bottom: 6px; right: 8px;">Right</span>
      </div>
      <div class="hint" style="margin-top:4px;">Top / Front / Right (orthographic) + Isometric. X,Y,Z or U,V,W. Updates after Convert.</div>
    </div>

  </div>

<script>
(function () {
  const $ = (id) => document.getElementById(id);

  function parseTokenNumber(tok) {
    // tok like "V47.729" or "W-1.761"
    const m = tok.match(/^([A-Za-z])([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)$/);
    if (!m) return null;
    return { letter: m[1].toUpperCase(), value: Number(m[2]) };
  }

  function isLineNumberToken(tok, prefix) {
    const p = (prefix || "N").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return new RegExp("^" + p + "[-+]?\\d+$", "i").test(tok);
  }

  function formatFixed(n, places) {
    if (!Number.isFinite(n)) return "";
    // keep trailing zeros like FileMaker output
    return n.toFixed(places);
  }

  function convertText(inputText, opts) {
    // Match FileMaker inputTextCleanup: single Substitute( "¶¶"; "¶" ) — one replace only
    let normalized = inputText.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    normalized = normalized.replace(/\n\n/g, "\n");
    const lines = normalized.split("\n");

    let prevV = null, prevW = null;
    let prevU = null;
    let prevXYZ = null; // for X/Y/Z mode (FileMaker has no A in distance)
    let prevHadX = false, prevHadY = false, prevHadZ = false; // which axes were on previous line (FileMaker clears missing to "")
    let cumDeg = 0;
    const passWidth = Number(opts.passWidth);
    const safePassWidth = Number.isFinite(passWidth) && passWidth !== 0 ? passWidth : 0.5;
    let nVal = opts.nStart;
    const linePrefix = (opts.lineNumberType || "N").trim() || "N";
    const rotFmt = opts.rotQtyFormat === "colon" ? "colon" : "semicolon";
    const rotQtySuffix = rotFmt === "colon" ? " :rotQty-" : " ;rotQty=";

    const outLines = [];
    let lastD = null;

    for (let rawLine of lines) {
      // Preserve completely blank lines
      if (rawLine.trim().length === 0) {
        outLines.push(rawLine);
        continue;
      }

      const leadingWS = rawLine.match(/^\s*/)?.[0] ?? "";
      const trimmed = rawLine.trim();
      const tokens = trimmed.split(/\s+/);

      // Handle line numbering (using lineNumberType prefix)
      const hasN = tokens.length > 0 && isLineNumberToken(tokens[0], linePrefix);
      const mode = opts.lineMode;

      if (mode === "add") {
        if (!hasN) {
          tokens.unshift(linePrefix + String(nVal));
          nVal += opts.nInc;
        }
      } else if (mode === "replace") {
        if (hasN) tokens.shift();
        tokens.unshift(linePrefix + String(nVal));
        nVal += opts.nInc;
      } else if (mode === "keep") {
        // do nothing (keep if present, don't add)
      } else {
        // none: if user wants none, remove existing line number
        if (hasN) tokens.shift();
      }

      // Parse all position axes (FileMaker supports X/Y/Z and U/V/W)
      let vTokIdx = -1, wTokIdx = -1, vVal = null, wVal = null;
      let uTokIdx = -1, uVal = null;
      let xVal = null, yVal = null, zVal = null, aVal = null;
      let xIdx = -1, yIdx = -1, zIdx = -1, aIdx = -1;

      for (let i = 0; i < tokens.length; i++) {
        const parsed = parseTokenNumber(tokens[i]);
        if (!parsed) continue;
        const letter = parsed.letter;
        const val = parsed.value;
        if (letter === "U") { uTokIdx = i; uVal = val; }
        else if (letter === "V") { vTokIdx = i; vVal = val; }
        else if (letter === "W") { wTokIdx = i; wVal = val; }
        else if (letter === "X") { xIdx = i; xVal = val; }
        else if (letter === "Y") { yIdx = i; yVal = val; }
        else if (letter === "Z") { zIdx = i; zVal = val; }
        else if (letter === "A") { aIdx = i; aVal = val; }
      }

      const hasVW = vTokIdx !== -1 && wTokIdx !== -1 && Number.isFinite(vVal) && Number.isFinite(wVal);
      const hasUW = uTokIdx !== -1 && wTokIdx !== -1 && Number.isFinite(uVal) && Number.isFinite(wVal);
      // FileMaker uses only X,Y,Z for 3-axis distance (no A); A is still kept in the output line
      const xyzAxes = [];
      if (xIdx >= 0 && Number.isFinite(xVal)) xyzAxes.push({ letter: "X", idx: xIdx, val: xVal });
      if (yIdx >= 0 && Number.isFinite(yVal)) xyzAxes.push({ letter: "Y", idx: yIdx, val: yVal });
      if (zIdx >= 0 && Number.isFinite(zVal)) xyzAxes.push({ letter: "Z", idx: zIdx, val: zVal });
      const hasXYZ = xyzAxes.length >= 1;

      let segmentDistance = 0;
      let insertAfterIdx = -1;
      let useVW = false;
      let useUW = false;

      if (hasVW) {
        useVW = true;
        insertAfterIdx = Math.max(vTokIdx, wTokIdx);
        if (prevV === null || prevW === null) {
          prevV = vVal; prevW = wVal;
          outLines.push(leadingWS + tokens.join(" ") + rotQtySuffix);
          continue;
        }
        const dV = vVal - prevV, dW = wVal - prevW;
        segmentDistance = Math.sqrt(dV * dV + dW * dW);
        prevV = vVal; prevW = wVal;
      } else if (hasUW) {
        useUW = true;
        insertAfterIdx = Math.max(uTokIdx, wTokIdx);
        if (prevU === null || prevW === null) {
          prevU = uVal; prevW = wVal;
          outLines.push(leadingWS + tokens.join(" ") + rotQtySuffix);
          continue;
        }
        const dU = uVal - prevU, dW = wVal - prevW;
        segmentDistance = Math.sqrt(dU * dU + dW * dW);
        prevU = uVal; prevW = wVal;
      } else if (hasXYZ) {
        // FileMaker: segmentDistance = Sqrt((ΔX)² + (ΔY)² + (ΔZ)²); missing axis = 0
        if (prevXYZ === null) {
          prevXYZ = { X: 0, Y: 0, Z: 0 };
          for (const a of xyzAxes) prevXYZ[a.letter] = a.val;
          prevHadX = xIdx >= 0; prevHadY = yIdx >= 0; prevHadZ = zIdx >= 0;
          insertAfterIdx = Math.max(...xyzAxes.map(a => a.idx));
          // First point: no D, rotQty with no value (same as FileMaker when lineCount is 1)
          outLines.push(leadingWS + tokens.join(" ") + rotQtySuffix);
          continue;
        }
        // FileMaker: missing axis = 0 in distance (cleared each line). So last = prev had ? prevVal : 0, cur = this line has ? val : 0
        const lastX = prevHadX ? prevXYZ.X : 0, lastY = prevHadY ? prevXYZ.Y : 0, lastZ = prevHadZ ? prevXYZ.Z : 0;
        const curX = (xIdx >= 0 && Number.isFinite(xVal)) ? xVal : 0;
        const curY = (yIdx >= 0 && Number.isFinite(yVal)) ? yVal : 0;
        const curZ = (zIdx >= 0 && Number.isFinite(zVal)) ? zVal : 0;
        const dx = curX - lastX, dy = curY - lastY, dz = curZ - lastZ;
        segmentDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);
        if (xVal != null && Number.isFinite(xVal)) prevXYZ.X = xVal;
        if (yVal != null && Number.isFinite(yVal)) prevXYZ.Y = yVal;
        if (zVal != null && Number.isFinite(zVal)) prevXYZ.Z = zVal;
        prevHadX = xIdx >= 0; prevHadY = yIdx >= 0; prevHadZ = zIdx >= 0;
        insertAfterIdx = Math.max(...xyzAxes.map(a => a.idx));
      }

      if (!useVW && !useUW && !hasXYZ) {
        outLines.push(rawLine);
        continue;
      }

      // Compute rotQty and D (same for VW and XYZ)
      const rotQty = Math.round((segmentDistance / safePassWidth) * 1e6) / 1e6;
      const deltaDeg = rotQty * 360;
      cumDeg += deltaDeg;
      const D = opts.startD + cumDeg;
      lastD = D;

      // Keep only G-code-like tokens (letter + number) so stray bare numbers from input don't appear in output
      const tokensOut = tokens.filter(t => /^[A-Za-z][-+]?\d*\.?\d*(?:[eE][-+]?\d+)?$/i.test(t) || /^[;:]/.test(t));
      for (let i = tokensOut.length - 1; i >= 0; i--) {
        if (/^D[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?$/i.test(tokensOut[i])) tokensOut.splice(i, 1);
      }
      const Dtok = "D" + formatFixed(D, 5);
      // Insert D after the last position axis (W for VW; rightmost of X,Y,Z,A for XYZ)
      let insertPos = insertAfterIdx + 1;
      let dIdxNow = -1;
      const reAxis = useVW || useUW ? /^W[-+]?\d/i : /^[XYZA][-+]?\d/i;
      for (let i = 0; i < tokensOut.length; i++) {
        if (reAxis.test(tokensOut[i])) dIdxNow = i;
      }
      if (dIdxNow >= 0) insertPos = dIdxNow + 1;
      tokensOut.splice(insertPos, 0, Dtok);

      let rotTxt = formatFixed(rotQty, 6);
      if (rotFmt === "semicolon" && rotTxt.startsWith("0.")) rotTxt = rotTxt.slice(1);
      if (rotFmt === "semicolon" && rotTxt.startsWith("-0.")) rotTxt = "-" + rotTxt.slice(2);
      outLines.push(leadingWS + tokensOut.join(" ") + rotQtySuffix + rotTxt);
    }

    return { text: outLines.join("\n"), finalLathePosition: lastD };
  }

  // Extract path points from input for toolpath visualizer (continuous path: missing axis = previous)
  function extractPathPoints(inputText) {
    let normalized = inputText.replace(/\r\n/g, "\n").replace(/\r/g, "\n").replace(/\n\n/g, "\n");
    const lines = normalized.split("\n");
    const points = [];
    let prevV = null, prevW = null;
    let prevX = null, prevY = null, prevZ = null;
    const linePrefix = ($("lineNumberType") && $("lineNumberType").value) ? ($("lineNumberType").value || "N").trim() : "N";

    for (const rawLine of lines) {
      const trimmed = rawLine.trim();
      if (!trimmed.length) continue;
      const tokens = trimmed.split(/\s+/);
      if (tokens.length && isLineNumberToken(tokens[0], linePrefix)) tokens.shift();

      let vVal = null, wVal = null, uVal = null, xVal = null, yVal = null, zVal = null;
      for (let i = 0; i < tokens.length; i++) {
        const p = parseTokenNumber(tokens[i]);
        if (!p) continue;
        const letter = p.letter, val = p.value;
        if (letter === "U") uVal = val;
        else if (letter === "V") vVal = val;
        else if (letter === "W") wVal = val;
        else if (letter === "X") xVal = val;
        else if (letter === "Y") yVal = val;
        else if (letter === "Z") zVal = val;
      }

      const hasVW = vVal != null && wVal != null && Number.isFinite(vVal) && Number.isFinite(wVal);
      const hasUW = uVal != null && wVal != null && Number.isFinite(uVal) && Number.isFinite(wVal);
      const hasXYZ = (xVal != null && Number.isFinite(xVal)) || (yVal != null && Number.isFinite(yVal)) || (zVal != null && Number.isFinite(zVal));

      if (hasVW) {
        const v = Number(vVal), w = Number(wVal);
        points.push({ v, w });
        prevV = v; prevW = w;
      } else if (hasUW) {
        const u = Number(uVal), w = Number(wVal);
        points.push({ u, w });
      } else if (hasXYZ) {
        const x = (xVal != null && Number.isFinite(xVal)) ? Number(xVal) : (prevX != null ? prevX : 0);
        const y = (yVal != null && Number.isFinite(yVal)) ? Number(yVal) : (prevY != null ? prevY : 0);
        const z = (zVal != null && Number.isFinite(zVal)) ? Number(zVal) : (prevZ != null ? prevZ : 0);
        if (prevX === null && prevY === null && prevZ === null) {
          points.push({ x, y, z });
        } else {
          points.push({ x, y, z });
        }
        prevX = x; prevY = y; prevZ = z;
      }
    }

    if (points.length >= 2 && points[0].v !== undefined) return { points, mode: "vw" };
    if (points.length >= 2 && points[0].u !== undefined) return { points, mode: "uw" };
    if (points.length >= 2 && (points[0].x !== undefined || points[0].z !== undefined)) return { points, mode: "xyz" };
    return { points: [], mode: "xyz" };
  }

  function drawToolpath(canvas, data) {
    const ctx = canvas.getContext("2d");
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const wrap = canvas.closest(".toolpath-wrap");
    const cw = wrap && wrap.clientWidth > 0 ? wrap.clientWidth : 600;
    const ch = Math.min(320, wrap && wrap.clientHeight > 0 ? wrap.clientHeight : 280);
    if (canvas.width !== cw * dpr || canvas.height !== ch * dpr) {
      canvas.width = cw * dpr;
      canvas.height = ch * dpr;
      canvas.style.width = cw + "px";
      canvas.style.height = ch + "px";
    }
    const drawW = cw;
    const drawH = ch;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    const isDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
    ctx.fillStyle = isDark ? "#1a1a1a" : "#f0f0f0";
    ctx.fillRect(0, 0, drawW, drawH);
    if (!ctx || !data || !data.points.length) return;

    const { points, mode } = data;
    // Normalize to 3D (x,y,z) for all views. V,W or U,W -> (x, y, 0)
    const pts3 = points.map(p => {
      if (mode === "vw") return { x: p.v, y: p.w, z: 0 };
      if (mode === "uw") return { x: p.u, y: p.w, z: 0 };
      return {
        x: p.x != null ? p.x : 0,
        y: p.y != null ? p.y : 0,
        z: p.z != null ? p.z : 0
      };
    });

    const halfW = drawW / 2;
    const halfH = drawH / 2;
    const pad = 8;
    const views = [
      { name: "Top",   x: 0,      y: 0,      w: halfW, h: halfH, toScreen: (p) => ({ sx: p.x, sy: p.y }) },
      { name: "Iso",   x: halfW,  y: 0,      w: halfW, h: halfH, toScreen: (p) => {
        const C = Math.cos(Math.PI / 6), S = Math.sin(Math.PI / 6);
        return { sx: (p.x - p.y) * C, sy: p.z - (p.x + p.y) * S };
      }},
      { name: "Front", x: 0,      y: halfH,  w: halfW, h: halfH, toScreen: (p) => ({ sx: p.x, sy: p.z }) },
      { name: "Right", x: halfW,  y: halfH,  w: halfW, h: halfH, toScreen: (p) => ({ sx: p.y, sy: p.z }) }
    ];

    ctx.strokeStyle = isDark ? "#00d4aa" : "#0a6b5a";
    ctx.fillStyle = isDark ? "#00d4aa" : "#0a6b5a";
    ctx.lineWidth = 1.5;
    ctx.lineJoin = "round";
    ctx.lineCap = "round";

    views.forEach(view => {
      const plotW = view.w - 2 * pad;
      const plotH = view.h - 2 * pad;
      const proj = pts3.map(p => view.toScreen(p));
      let minSx = Infinity, maxSx = -Infinity, minSy = Infinity, maxSy = -Infinity;
      proj.forEach(({ sx, sy }) => {
        minSx = Math.min(minSx, sx); maxSx = Math.max(maxSx, sx);
        minSy = Math.min(minSy, sy); maxSy = Math.max(maxSy, sy);
      });
      const rangeSx = maxSx - minSx || 1;
      const rangeSy = maxSy - minSy || 1;
      const scale = Math.min(plotW / rangeSx, plotH / rangeSy);
      const ox = view.x + pad + (plotW - rangeSx * scale) / 2 - minSx * scale;
      const oy = view.y + pad + (plotH - rangeSy * scale) / 2 - minSy * scale;
      const toX = (sx) => ox + sx * scale;
      const toY = (sy) => oy + sy * scale;

      ctx.save();
      ctx.beginPath();
      ctx.rect(view.x, view.y, view.w, view.h);
      ctx.clip();
      ctx.strokeStyle = isDark ? "rgba(127,127,127,.4)" : "rgba(0,0,0,.15)";
      ctx.strokeRect(view.x + 0.5, view.y + 0.5, view.w - 1, view.h - 1);
      ctx.strokeStyle = isDark ? "#00d4aa" : "#0a6b5a";
      ctx.fillStyle = isDark ? "#00d4aa" : "#0a6b5a";
      ctx.beginPath();
      ctx.moveTo(toX(proj[0].sx), toY(proj[0].sy));
      for (let i = 1; i < proj.length; i++) ctx.lineTo(toX(proj[i].sx), toY(proj[i].sy));
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(toX(proj[0].sx), toY(proj[0].sy), 2.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    });
  }

  function updateToolpath() {
    const canvas = $("toolpath");
    if (!canvas) return;
    const data = extractPathPoints($("input").value || "");
    drawToolpath(canvas, data);
  }

  function setStatus(msg) {
    $("status").textContent = msg || "";
    if (msg) setTimeout(() => { $("status").textContent = ""; }, 2500);
  }

  function doConvert() {
    const startD = Number($("startD").value);
    const lineMode = ($("lineMode") && $("lineMode").value) ? $("lineMode").value : "none";
    const nStart = $("nStart") && $("nStart").value !== "" ? Number($("nStart").value) : 10;
    const nInc = $("nInc") && $("nInc").value !== "" ? Number($("nInc").value) : 10;
    const lineNumberType = ($("lineNumberType").value || "N").trim() || "N";
    const rotQtyFormat = ($("rotQtyFormat") && $("rotQtyFormat").value) ? $("rotQtyFormat").value : "semicolon";

    const passW = Number($("passWidth").value);
    const passWidthVal = Number.isFinite(passW) && passW !== 0 ? passW : 0.5;

    const result = convertText($("input").value, {
      startD: Number.isFinite(startD) ? startD : 0,
      lineMode,
      nStart: Number.isFinite(nStart) ? nStart : 10,
      nInc: Number.isFinite(nInc) ? nInc : 10,
      lineNumberType,
      rotQtyFormat,
      passWidth: passWidthVal,
    });

    $("output").value = result.text;
    $("finalLathePosition").value = result.finalLathePosition != null ? String(result.finalLathePosition) : "";
    setStatus("Converted.");
    updateToolpath();
  }

  $("btnConvert").addEventListener("click", doConvert);

  // FileMaker: travelSpeedF = Round(passWidth * desiredSurfaceSpeed / (partDiameter*Pi), 0)
  function updateTravelSpeedF() {
    const partD = Number($("partDiameter").value);
    const dSpeed = Number($("desiredSurfaceSpeed").value);
    const pWidth = Number($("passWidth").value);
    if (Number.isFinite(partD) && partD > 0 && Number.isFinite(dSpeed) && Number.isFinite(pWidth) && pWidth > 0) {
      const f = Math.round((pWidth * dSpeed) / (partD * Math.PI));
      $("travelSpeedF").value = String(f);
    }
  }
  ["partDiameter", "desiredSurfaceSpeed", "passWidth"].forEach(id => {
    $(id).addEventListener("input", updateTravelSpeedF);
  });
  updateTravelSpeedF();

  updateToolpath();
  const ro = typeof ResizeObserver !== "undefined" ? new ResizeObserver(() => updateToolpath()) : null;
  const wrap = document.querySelector(".toolpath-wrap");
  if (ro && wrap) ro.observe(wrap);

  $("btnCopy").addEventListener("click", async () => {
    try {
      await navigator.clipboard.writeText($("output").value || "");
      setStatus("Copied to clipboard.");
    } catch (e) {
      // Fallback
      $("output").focus();
      $("output").select();
      document.execCommand("copy");
      setStatus("Copied (fallback).");
    }
  });

  $("btnDownload").addEventListener("click", () => {
    const content = $("output").value || "";
    const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "converted.nc";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    setStatus("Download started.");
  });

})();
</script>
</body>
</html>
