<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lathe G-code Converter (V/W → D + rotQty)</title>
  <style>
    :root { color-scheme: light dark; }
    *, *::before, *::after { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 16px; }
    .wrap { max-width: 1200px; margin: 0 auto; display: grid; gap: 12px; }
    .bar { display: flex; flex-wrap: wrap; gap: 10px; align-items: end; }
    .card { border: 1px solid rgba(127,127,127,.35); border-radius: 12px; padding: 12px; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .grid .card { min-width: 0; }
    textarea { box-sizing: border-box; width: 100%; min-height: 420px; resize: vertical; border-radius: 10px; border: 1px solid rgba(127,127,127,.35); padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12.5px; line-height: 1.35; }
    label { display: grid; gap: 6px; font-size: 13px; }
    input, select, button { font-size: 14px; }
    input, select { border-radius: 10px; border: 1px solid rgba(127,127,127,.35); padding: 8px 10px; }
    button { border-radius: 10px; border: 1px solid rgba(127,127,127,.35); padding: 9px 12px; cursor: pointer; }
    button.primary { font-weight: 650; }
    .hint { opacity: .8; font-size: 12px; line-height: 1.35; }
    .pill { display:inline-flex; gap:8px; align-items:center; padding:6px 10px; border-radius: 999px; border: 1px solid rgba(127,127,127,.35); font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .field-row { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 10px 16px; align-items: end; }
    .field-row .full { grid-column: 1 / -1; }
    .field-group { display: flex; flex-wrap: wrap; gap: 10px; align-items: end; }
    .start-pos { background: rgba(0,180,0,.12); }
    .final-pos { background: rgba(220,0,0,.12); }
    .viz-card { min-width: 0; }
    .viz-wrap { position: relative; width: 100%; max-width: 100%; border-radius: 10px; overflow: hidden; background: rgba(0,0,0,.04); }
    .viz-wrap canvas { display: block; width: 100%; height: auto; max-height: 380px; vertical-align: bottom; }
    @media (prefers-color-scheme: dark) { .viz-wrap { background: rgba(255,255,255,.06); } }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } textarea { min-height: 320px; } }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:space-between;">
        <div>
          <div style="font-size:18px; font-weight:700;">Lathe G-code Converter</div>
          <div class="hint">Accepts lines with <span class="mono">V</span>/<span class="mono">W</span> (planar) or <span class="mono">X</span>, <span class="mono">Z</span>, <span class="mono">A</span> (e.g. lathe). Appends <span class="mono">D</span> (cumulative degrees) + a <span class="mono">;rotQty=</span> comment, matching your FileMaker utility’s behavior from the sample.</div>
        </div>
        <div class="pill"><span>Formula:</span> <span class="mono">rotQty = 2 * sqrt((ΔV)² + (ΔW)²)</span> · <span class="mono">ΔD = rotQty * 360</span></div>
      </div>
    </div>

    <div class="card">
      <div style="font-weight:650; margin-bottom:10px;">Program details</div>
      <div class="field-row">
        <label><span class="mono">programID</span><input id="programID" type="text" /></label>
        <label><span class="mono">operationID</span><input id="operationID" type="text" /></label>
        <label><span class="mono">translation</span><input id="translation" type="text" placeholder="e.g. Spun Lathe Part" /></label>
        <label><span class="mono">lineNumberType</span><input id="lineNumberType" type="text" value="N" placeholder="N" /></label>
        <label><span class="mono">passWidth</span><input id="passWidth" type="number" step="0.01" value="0.5" /></label>
        <label class="full"><span class="mono">programName</span><input id="programName" type="text" placeholder="Program name" style="width:100%;" /></label>
        <label class="full"><span class="mono">description</span><textarea id="description" rows="2" placeholder="Optional description" style="min-height:52px; resize:vertical;"></textarea></label>
      </div>
    </div>

    <div class="card">
      <div style="font-weight:650; margin-bottom:10px;">Conversion parameters</div>
      <div class="field-group">
        <label style="min-width:120px;"><span class="mono">partDiameter</span><input id="partDiameter" type="number" step="0.01" value="1.25" /></label>
        <label style="min-width:120px;"><span class="mono">travelSpeedF</span><input id="travelSpeedF" type="number" step="0.1" value="25" readonly title="Calculated: passWidth × desiredSurfaceSpeed ÷ (partDiameter × π)" /></label>
        <label style="min-width:140px;"><span class="mono">desiredSurfaceSpeed</span><input id="desiredSurfaceSpeed" type="number" step="0.1" value="200" /></label>
        <label style="min-width:160px;"><span class="mono">startingLathePosition</span><input id="startD" class="start-pos" type="number" step="0.00001" value="0" /></label>
        <label style="min-width:160px;"><span class="mono">finalLathePosition</span><input id="finalLathePosition" class="final-pos" type="number" step="0.00001" value="" readonly placeholder="Set after convert" /></label>
      </div>
      <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:12px;">
        <button class="primary" id="btnConvert">Convert</button>
        <button id="btnCopy">Copy output</button>
        <button id="btnDownload">Download .nc</button>
        <span class="hint" id="status"></span>
      </div>
      <div class="hint" style="margin-top:8px;"><span class="mono">travelSpeedF</span> = Round(passWidth × desiredSurfaceSpeed ÷ (partDiameter × π), 0). Used as feed (F) reference.</div>
    </div>


    <div class="grid">
      <div class="card">
        <div style="font-weight:650; margin-bottom:8px;">Input</div>
        <textarea id="input" placeholder="Paste your V/W program here..."></textarea>
      </div>

      <div class="card">
        <div style="font-weight:650; margin-bottom:8px;">Output</div>
        <textarea id="output" placeholder="Converted output appears here..." readonly></textarea>
      </div>
    </div>

    <div class="card viz-card">
      <div style="font-weight:650; margin-bottom:8px;">Toolpath (V / W)</div>
      <div class="hint" style="margin-bottom:8px;">Path from V and W values in the input. V → horizontal, W → vertical.</div>
      <div class="viz-wrap">
        <canvas id="toolpathCanvas" width="800" height="400"></canvas>
      </div>
    </div>

    <div class="hint">
      Tip for Notion: host this file (Cloudflare Pages / Vercel / Netlify) and embed the URL with Notion’s <span class="mono">/embed</span> block. Notion won’t run raw HTML/JS pasted into a page.
    </div>
  </div>

<script>
(function () {
  const $ = (id) => document.getElementById(id);

  function parseTokenNumber(tok) {
    // tok like "V47.729" or "W-1.761"
    const m = tok.match(/^([A-Za-z])([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)$/);
    if (!m) return null;
    return { letter: m[1].toUpperCase(), value: Number(m[2]) };
  }

  function isLineNumberToken(tok, prefix) {
    const p = (prefix || "N").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return new RegExp("^" + p + "[-+]?\\d+$", "i").test(tok);
  }

  function formatFixed(n, places) {
    if (!Number.isFinite(n)) return "";
    // keep trailing zeros like FileMaker output
    return n.toFixed(places);
  }

  function convertText(inputText, opts) {
    // Match FileMaker inputTextCleanup: collapse double newlines (¶¶ → ¶)
    let normalized = inputText.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    while (normalized.indexOf("\n\n") !== -1) normalized = normalized.replace(/\n\n/g, "\n");
    const lines = normalized.split("\n");

    let prevV = null, prevW = null;
    let prevXYZ = null; // for X/Y/Z/A mode: { X?, Y?, Z?, A? }
    let cumDeg = 0;
    const passWidth = Number(opts.passWidth);
    const safePassWidth = Number.isFinite(passWidth) && passWidth > 0 ? passWidth : 0.5;
    let nVal = opts.nStart;
    const linePrefix = (opts.lineNumberType || "N").trim() || "N";
    const rotFmt = opts.rotQtyFormat === "colon" ? "colon" : "semicolon";
    const rotQtySuffix = rotFmt === "colon" ? " :rotQty-" : " ;rotQty=";

    const outLines = [];
    let lastD = null;

    for (let rawLine of lines) {
      // Preserve completely blank lines
      if (rawLine.trim().length === 0) {
        outLines.push(rawLine);
        continue;
      }

      const leadingWS = rawLine.match(/^\s*/)?.[0] ?? "";
      const trimmed = rawLine.trim();
      const tokens = trimmed.split(/\s+/);

      // Handle line numbering (using lineNumberType prefix)
      const hasN = tokens.length > 0 && isLineNumberToken(tokens[0], linePrefix);
      const mode = opts.lineMode;

      if (mode === "add") {
        if (!hasN) {
          tokens.unshift(linePrefix + String(nVal));
          nVal += opts.nInc;
        }
      } else if (mode === "replace") {
        if (hasN) tokens.shift();
        tokens.unshift(linePrefix + String(nVal));
        nVal += opts.nInc;
      } else if (mode === "keep") {
        // do nothing (keep if present, don't add)
      } else {
        // none: if user wants none, remove existing line number
        if (hasN) tokens.shift();
      }

      // Parse all position axes (FileMaker supports X/Y/Z and U/V/W)
      let vTokIdx = -1, wTokIdx = -1, vVal = null, wVal = null;
      let xVal = null, yVal = null, zVal = null, aVal = null;
      let xIdx = -1, yIdx = -1, zIdx = -1, aIdx = -1;

      for (let i = 0; i < tokens.length; i++) {
        const parsed = parseTokenNumber(tokens[i]);
        if (!parsed) continue;
        const letter = parsed.letter;
        const val = parsed.value;
        if (letter === "V") { vTokIdx = i; vVal = val; }
        else if (letter === "W") { wTokIdx = i; wVal = val; }
        else if (letter === "X") { xIdx = i; xVal = val; }
        else if (letter === "Y") { yIdx = i; yVal = val; }
        else if (letter === "Z") { zIdx = i; zVal = val; }
        else if (letter === "A") { aIdx = i; aVal = val; }
      }

      const hasVW = vTokIdx !== -1 && wTokIdx !== -1 && Number.isFinite(vVal) && Number.isFinite(wVal);
      const xyzAxes = []; // { letter, idx, val } for X,Y,Z,A that are present
      if (xIdx >= 0 && Number.isFinite(xVal)) xyzAxes.push({ letter: "X", idx: xIdx, val: xVal });
      if (yIdx >= 0 && Number.isFinite(yVal)) xyzAxes.push({ letter: "Y", idx: yIdx, val: yVal });
      if (zIdx >= 0 && Number.isFinite(zVal)) xyzAxes.push({ letter: "Z", idx: zIdx, val: zVal });
      if (aIdx >= 0 && Number.isFinite(aVal)) xyzAxes.push({ letter: "A", idx: aIdx, val: aVal });
      const hasXYZ = xyzAxes.length >= 1; // FileMaker: at least one of X,Y,Z; we include A (e.g. X,Z,A lathe)

      let segmentDistance = 0;
      let insertAfterIdx = -1;
      let useVW = false;

      if (hasVW) {
        useVW = true;
        insertAfterIdx = Math.max(vTokIdx, wTokIdx);
        if (prevV === null || prevW === null) {
          prevV = vVal; prevW = wVal;
          outLines.push(leadingWS + tokens.join(" ") + rotQtySuffix);
          continue;
        }
        const dV = vVal - prevV, dW = wVal - prevW;
        segmentDistance = Math.sqrt(dV * dV + dW * dW);
        prevV = vVal; prevW = wVal;
      } else if (hasXYZ) {
        // FileMaker 3-axis / lathe: segmentDistance = Sqrt((ΔX)² + (ΔY)² + (ΔZ)²); we include A
        if (prevXYZ === null) {
          prevXYZ = {};
          for (const a of xyzAxes) prevXYZ[a.letter] = a.val;
          insertAfterIdx = Math.max(...xyzAxes.map(a => a.idx));
          outLines.push(leadingWS + tokens.join(" ") + rotQtySuffix);
          continue;
        }
        let sumSq = 0;
        for (const a of xyzAxes) {
          const prev = prevXYZ[a.letter] != null ? prevXYZ[a.letter] : 0;
          const d = a.val - prev;
          sumSq += d * d;
        }
        segmentDistance = Math.sqrt(sumSq);
        for (const a of xyzAxes) prevXYZ[a.letter] = a.val;
        insertAfterIdx = Math.max(...xyzAxes.map(a => a.idx));
      }

      if (!useVW && !hasXYZ) {
        outLines.push(rawLine);
        continue;
      }

      // Compute rotQty and D (same for VW and XYZ)
      const rotQty = Math.round((segmentDistance / safePassWidth) * 1e6) / 1e6;
      const deltaDeg = rotQty * 360;
      cumDeg += deltaDeg;
      const D = opts.startD + cumDeg;
      lastD = D;

      const tokensOut = tokens.slice();
      for (let i = tokensOut.length - 1; i >= 0; i--) {
        if (/^D[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?$/i.test(tokensOut[i])) tokensOut.splice(i, 1);
      }
      const Dtok = "D" + formatFixed(D, 5);
      // Insert D after the last position axis (W for VW; rightmost of X,Y,Z,A for XYZ)
      let insertPos = insertAfterIdx + 1;
      let dIdxNow = -1;
      const reAxis = useVW ? /^W[-+]?\d/i : /^[XYZA][-+]?\d/i;
      for (let i = 0; i < tokensOut.length; i++) {
        if (reAxis.test(tokensOut[i])) dIdxNow = i;
      }
      if (dIdxNow >= 0) insertPos = dIdxNow + 1;
      tokensOut.splice(insertPos, 0, Dtok);

      let rotTxt = formatFixed(rotQty, 6);
      if (rotFmt === "semicolon" && rotTxt.startsWith("0.")) rotTxt = rotTxt.slice(1);
      if (rotFmt === "semicolon" && rotTxt.startsWith("-0.")) rotTxt = "-" + rotTxt.slice(2);
      outLines.push(leadingWS + tokensOut.join(" ") + rotQtySuffix + rotTxt);
    }

    return { text: outLines.join("\n"), finalLathePosition: lastD };
  }

  function extractVWPoints(inputText) {
    const lines = (inputText || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n").split("\n");
    const points = [];
    for (const rawLine of lines) {
      const trimmed = rawLine.trim();
      if (!trimmed) continue;
      const tokens = trimmed.split(/\s+/);
      let vVal = null, wVal = null;
      for (let i = 0; i < tokens.length; i++) {
        const parsed = parseTokenNumber(tokens[i]);
        if (!parsed) continue;
        if (parsed.letter === "V") vVal = parsed.value;
        if (parsed.letter === "W") wVal = parsed.value;
      }
      if (vVal != null && wVal != null && Number.isFinite(vVal) && Number.isFinite(wVal)) {
        points.push({ v: vVal, w: wVal });
      }
    }
    return points;
  }

  function drawToolpath(canvas, points) {
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const w = Math.round(rect.width * dpr);
    const h = Math.round(rect.height * dpr);
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    const padding = { top: 28, right: 28, bottom: 32, left: 36 };
    const plotW = w - padding.left - padding.right;
    const plotH = h - padding.top - padding.bottom;

    ctx.clearRect(0, 0, w, h);

    if (points.length === 0) {
      ctx.save();
      ctx.fillStyle = "rgba(127,127,127,.5)";
      ctx.font = "14px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Enter or paste V/W lines to see the toolpath", w / 2, h / 2);
      ctx.restore();
      return;
    }

    let minV = points[0].v, maxV = points[0].v, minW = points[0].w, maxW = points[0].w;
    for (let i = 1; i < points.length; i++) {
      minV = Math.min(minV, points[i].v); maxV = Math.max(maxV, points[i].v);
      minW = Math.min(minW, points[i].w); maxW = Math.max(maxW, points[i].w);
    }
    const rangeV = maxV - minV || 1;
    const rangeW = maxW - minW || 1;
    const marginV = rangeV * 0.08 || 0.5;
    const marginW = rangeW * 0.08 || 0.5;
    const loV = minV - marginV, hiV = maxV + marginV;
    const loW = minW - marginW, hiW = maxW + marginW;
    const spanV = hiV - loV, spanW = hiW - loW;

    function toX(v) { return padding.left + ((v - loV) / spanV) * plotW; }
    function toY(w) { return padding.top + plotH - ((w - loW) / spanW) * plotH; }

    // Grid
    ctx.strokeStyle = "rgba(127,127,127,.2)";
    ctx.lineWidth = 1;
    const gridSteps = 5;
    for (let i = 0; i <= gridSteps; i++) {
      const v = loV + (i / gridSteps) * spanV;
      const wVal = loW + (i / gridSteps) * spanW;
      ctx.beginPath();
      ctx.moveTo(toX(v), padding.top);
      ctx.lineTo(toX(v), h - padding.bottom);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(padding.left, toY(wVal));
      ctx.lineTo(canvas.width - padding.right, toY(wVal));
      ctx.stroke();
    }

    // Axes
    ctx.strokeStyle = "rgba(127,127,127,.5)";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(padding.left, padding.top);
    ctx.lineTo(padding.left, h - padding.bottom);
    ctx.lineTo(w - padding.right, h - padding.bottom);
    ctx.stroke();

    ctx.fillStyle = "rgba(0,0,0,.7)";
    ctx.font = "12px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("V", (padding.left + w - padding.right) / 2, h - 6);
    ctx.save();
    ctx.translate(14, h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = "center";
    ctx.fillText("W", 0, 0);
    ctx.restore();

    // Path
    ctx.strokeStyle = "rgb(0, 100, 220)";
    ctx.lineWidth = 2.5;
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(toX(points[0].v), toY(points[0].w));
    for (let i = 1; i < points.length; i++) {
      ctx.lineTo(toX(points[i].v), toY(points[i].w));
    }
    ctx.stroke();

    // Points
    const r = 4;
    ctx.fillStyle = "rgb(0, 100, 220)";
    for (let i = 0; i < points.length; i++) {
      ctx.beginPath();
      ctx.arc(toX(points[i].v), toY(points[i].w), r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.strokeStyle = "rgba(255,255,255,.9)";
    ctx.lineWidth = 1.5;
    for (let i = 0; i < points.length; i++) {
      ctx.beginPath();
      ctx.arc(toX(points[i].v), toY(points[i].w), r, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  function updateToolpath() {
    const points = extractVWPoints($("input").value);
    drawToolpath($("toolpathCanvas"), points);
  }

  function setStatus(msg) {
    $("status").textContent = msg || "";
    if (msg) setTimeout(() => { $("status").textContent = ""; }, 2500);
  }

  function doConvert() {
    const startD = Number($("startD").value);
    const lineMode = ($("lineMode") && $("lineMode").value) ? $("lineMode").value : "none";
    const nStart = $("nStart") && $("nStart").value !== "" ? Number($("nStart").value) : 10;
    const nInc = $("nInc") && $("nInc").value !== "" ? Number($("nInc").value) : 10;
    const lineNumberType = ($("lineNumberType").value || "N").trim() || "N";
    const rotQtyFormat = ($("rotQtyFormat") && $("rotQtyFormat").value) ? $("rotQtyFormat").value : "semicolon";

    const passW = Number($("passWidth").value);
    const passWidthVal = Number.isFinite(passW) && passW > 0 ? passW : 0.5;

    const result = convertText($("input").value, {
      startD: Number.isFinite(startD) ? startD : 0,
      lineMode,
      nStart: Number.isFinite(nStart) ? nStart : 10,
      nInc: Number.isFinite(nInc) ? nInc : 10,
      lineNumberType,
      rotQtyFormat,
      passWidth: passWidthVal,
    });

    $("output").value = result.text;
    $("finalLathePosition").value = result.finalLathePosition != null ? String(result.finalLathePosition) : "";
    setStatus("Converted.");
    updateToolpath();
  }

  let toolpathDebounce = null;
  $("input").addEventListener("input", () => {
    if (toolpathDebounce) clearTimeout(toolpathDebounce);
    toolpathDebounce = setTimeout(updateToolpath, 180);
  });

  $("btnConvert").addEventListener("click", doConvert);

  // FileMaker: travelSpeedF = Round(passWidth * desiredSurfaceSpeed / (partDiameter*Pi), 0)
  function updateTravelSpeedF() {
    const partD = Number($("partDiameter").value);
    const dSpeed = Number($("desiredSurfaceSpeed").value);
    const pWidth = Number($("passWidth").value);
    if (Number.isFinite(partD) && partD > 0 && Number.isFinite(dSpeed) && Number.isFinite(pWidth) && pWidth > 0) {
      const f = Math.round((pWidth * dSpeed) / (partD * Math.PI));
      $("travelSpeedF").value = String(f);
    }
  }
  ["partDiameter", "desiredSurfaceSpeed", "passWidth"].forEach(id => {
    $(id).addEventListener("input", updateTravelSpeedF);
  });
  updateTravelSpeedF();

  // Initial draw (empty state message)
  updateToolpath();
  window.addEventListener("resize", () => { updateToolpath(); });

  $("btnCopy").addEventListener("click", async () => {
    try {
      await navigator.clipboard.writeText($("output").value || "");
      setStatus("Copied to clipboard.");
    } catch (e) {
      // Fallback
      $("output").focus();
      $("output").select();
      document.execCommand("copy");
      setStatus("Copied (fallback).");
    }
  });

  $("btnDownload").addEventListener("click", () => {
    const content = $("output").value || "";
    const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "converted.nc";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    setStatus("Download started.");
  });

})();
</script>
</body>
</html>
