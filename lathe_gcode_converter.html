<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lathe G-code Converter (V/W → D + rotQty)</title>
  <style>
    :root { color-scheme: light dark; }
    *, *::before, *::after { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 6px; }
    .wrap { max-width: 1200px; margin: 0 auto; display: grid; gap: 6px; }
    .bar { display: flex; flex-wrap: wrap; gap: 8px; align-items: end; }
    .card { border: 1px solid rgba(127,127,127,.35); border-radius: 8px; padding: 6px 8px; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
    .grid .card { min-width: 0; }
    textarea { box-sizing: border-box; width: 100%; min-height: 120px; height: 120px; resize: vertical; border-radius: 6px; border: 1px solid rgba(127,127,127,.35); padding: 6px 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 11px; line-height: 1.3; }
    label { display: grid; gap: 2px; font-size: 12px; }
    input, select, button { font-size: 13px; }
    input, select { border-radius: 6px; border: 1px solid rgba(127,127,127,.35); padding: 4px 6px; }
    button { border-radius: 6px; border: 1px solid rgba(127,127,127,.35); padding: 5px 8px; cursor: pointer; }
    button.primary { font-weight: 650; }
    .hint { opacity: .85; font-size: 11px; line-height: 1.25; }
    .pill { display:inline-flex; flex-wrap:wrap; gap:6px; align-items:center; padding:4px 8px; border-radius: 999px; border: 1px solid rgba(127,127,127,.35); font-size: 11px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .field-row { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 6px 10px; align-items: end; }
    .field-row .full { grid-column: 1 / -1; }
    .field-group { display: flex; flex-wrap: wrap; gap: 6px 8px; align-items: end; }
    .start-pos { background: rgba(0,180,0,.12); }
    .final-pos { background: rgba(220,0,0,.12); }
    .card-title { font-weight: 650; margin-bottom: 4px; font-size: 13px; }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div style="display:flex; flex-wrap:wrap; gap:6px; align-items:center; justify-content:space-between;">
        <div>
          <div style="font-size:15px; font-weight:700;">Lathe G-code Converter</div>
          <div class="hint">Accepts <span class="mono">V</span>/<span class="mono">W</span> or <span class="mono">X</span>,<span class="mono">Z</span>,<span class="mono">A</span>. Appends <span class="mono">D</span> + <span class="mono">;rotQty=</span> (FileMaker-compatible).</div>
        </div>
        <div class="pill"><span>Formula:</span> <span class="mono">segment = √((ΔX)²+(ΔY)²+(ΔZ)²)</span> or <span class="mono">√((ΔV)²+(ΔW)²)</span>; missing axis = 0 · <span class="mono">rotQty = segment ÷ passWidth</span> · <span class="mono">ΔD = rotQty × 360</span> (D cumulative)</div>
      </div>
    </div>

    <div class="card">
      <div class="card-title">Program details</div>
      <div class="field-row">
        <label><span class="mono">programID</span><input id="programID" type="text" /></label>
        <label><span class="mono">operationID</span><input id="operationID" type="text" /></label>
        <label><span class="mono">translation</span><input id="translation" type="text" placeholder="e.g. Spun Lathe Part" /></label>
        <label><span class="mono">lineNumberType</span><input id="lineNumberType" type="text" value="N" placeholder="N" /></label>
        <label><span class="mono">passWidth</span><input id="passWidth" type="number" step="0.01" value="0.5" /></label>
        <label class="full"><span class="mono">programName</span><input id="programName" type="text" placeholder="Program name" style="width:100%;" /></label>
        <label class="full"><span class="mono">description</span><textarea id="description" rows="1" placeholder="Optional description" style="min-height:32px; resize:vertical;"></textarea></label>
      </div>
    </div>

    <div class="card">
      <div class="card-title">Conversion parameters</div>
      <div class="field-group">
        <label style="min-width:120px;"><span class="mono">partDiameter</span><input id="partDiameter" type="number" step="0.01" value="1.25" /></label>
        <label style="min-width:120px;"><span class="mono">travelSpeedF</span><input id="travelSpeedF" type="number" step="0.1" value="25" readonly title="Calculated: passWidth × desiredSurfaceSpeed ÷ (partDiameter × π)" /></label>
        <label style="min-width:140px;"><span class="mono">desiredSurfaceSpeed</span><input id="desiredSurfaceSpeed" type="number" step="0.1" value="200" /></label>
        <label style="min-width:160px;"><span class="mono">startingLathePosition</span><input id="startD" class="start-pos" type="number" step="0.00001" value="0" /></label>
        <label style="min-width:160px;"><span class="mono">finalLathePosition</span><input id="finalLathePosition" class="final-pos" type="number" step="0.00001" value="" readonly placeholder="Set after convert" /></label>
      </div>
      <div style="display:flex; gap:6px; flex-wrap:wrap; align-items:center; margin-top:6px;">
        <button class="primary" id="btnConvert">Convert</button>
        <button id="btnCopy">Copy output</button>
        <button id="btnDownload">Download .nc</button>
        <span class="hint" id="status"></span>
      </div>
      <div class="hint" style="margin-top:4px;"><span class="mono">travelSpeedF</span> = Round(passWidth × desiredSurfaceSpeed ÷ (partDiameter × π), 0).</div>
    </div>


    <div class="grid">
      <div class="card">
        <div class="card-title">Input</div>
        <textarea id="input" placeholder="Paste G-code here..."></textarea>
      </div>

      <div class="card">
        <div class="card-title">Output</div>
        <textarea id="output" placeholder="Converted output..." readonly></textarea>
      </div>
    </div>

  </div>

<script>
(function () {
  const $ = (id) => document.getElementById(id);

  function parseTokenNumber(tok) {
    // tok like "V47.729" or "W-1.761"
    const m = tok.match(/^([A-Za-z])([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)$/);
    if (!m) return null;
    return { letter: m[1].toUpperCase(), value: Number(m[2]) };
  }

  function isLineNumberToken(tok, prefix) {
    const p = (prefix || "N").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return new RegExp("^" + p + "[-+]?\\d+$", "i").test(tok);
  }

  function formatFixed(n, places) {
    if (!Number.isFinite(n)) return "";
    // keep trailing zeros like FileMaker output
    return n.toFixed(places);
  }

  function convertText(inputText, opts) {
    // Match FileMaker inputTextCleanup: single Substitute( "¶¶"; "¶" ) — one replace only
    let normalized = inputText.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    normalized = normalized.replace(/\n\n/g, "\n");
    const lines = normalized.split("\n");

    let prevV = null, prevW = null;
    let prevXYZ = null; // for X/Y/Z mode (FileMaker has no A in distance)
    let prevHadX = false, prevHadY = false, prevHadZ = false; // which axes were on previous line (FileMaker clears missing to "")
    let cumDeg = 0;
    const passWidth = Number(opts.passWidth);
    const safePassWidth = Number.isFinite(passWidth) && passWidth !== 0 ? passWidth : 0.5;
    let nVal = opts.nStart;
    const linePrefix = (opts.lineNumberType || "N").trim() || "N";
    const rotFmt = opts.rotQtyFormat === "colon" ? "colon" : "semicolon";
    const rotQtySuffix = rotFmt === "colon" ? " :rotQty-" : " ;rotQty=";

    const outLines = [];
    let lastD = null;

    for (let rawLine of lines) {
      // Preserve completely blank lines
      if (rawLine.trim().length === 0) {
        outLines.push(rawLine);
        continue;
      }

      const leadingWS = rawLine.match(/^\s*/)?.[0] ?? "";
      const trimmed = rawLine.trim();
      const tokens = trimmed.split(/\s+/);

      // Handle line numbering (using lineNumberType prefix)
      const hasN = tokens.length > 0 && isLineNumberToken(tokens[0], linePrefix);
      const mode = opts.lineMode;

      if (mode === "add") {
        if (!hasN) {
          tokens.unshift(linePrefix + String(nVal));
          nVal += opts.nInc;
        }
      } else if (mode === "replace") {
        if (hasN) tokens.shift();
        tokens.unshift(linePrefix + String(nVal));
        nVal += opts.nInc;
      } else if (mode === "keep") {
        // do nothing (keep if present, don't add)
      } else {
        // none: if user wants none, remove existing line number
        if (hasN) tokens.shift();
      }

      // Parse all position axes (FileMaker supports X/Y/Z and U/V/W)
      let vTokIdx = -1, wTokIdx = -1, vVal = null, wVal = null;
      let xVal = null, yVal = null, zVal = null, aVal = null;
      let xIdx = -1, yIdx = -1, zIdx = -1, aIdx = -1;

      for (let i = 0; i < tokens.length; i++) {
        const parsed = parseTokenNumber(tokens[i]);
        if (!parsed) continue;
        const letter = parsed.letter;
        const val = parsed.value;
        if (letter === "V") { vTokIdx = i; vVal = val; }
        else if (letter === "W") { wTokIdx = i; wVal = val; }
        else if (letter === "X") { xIdx = i; xVal = val; }
        else if (letter === "Y") { yIdx = i; yVal = val; }
        else if (letter === "Z") { zIdx = i; zVal = val; }
        else if (letter === "A") { aIdx = i; aVal = val; }
      }

      const hasVW = vTokIdx !== -1 && wTokIdx !== -1 && Number.isFinite(vVal) && Number.isFinite(wVal);
      // FileMaker uses only X,Y,Z for 3-axis distance (no A); A is still kept in the output line
      const xyzAxes = [];
      if (xIdx >= 0 && Number.isFinite(xVal)) xyzAxes.push({ letter: "X", idx: xIdx, val: xVal });
      if (yIdx >= 0 && Number.isFinite(yVal)) xyzAxes.push({ letter: "Y", idx: yIdx, val: yVal });
      if (zIdx >= 0 && Number.isFinite(zVal)) xyzAxes.push({ letter: "Z", idx: zIdx, val: zVal });
      const hasXYZ = xyzAxes.length >= 1;

      let segmentDistance = 0;
      let insertAfterIdx = -1;
      let useVW = false;

      if (hasVW) {
        useVW = true;
        insertAfterIdx = Math.max(vTokIdx, wTokIdx);
        if (prevV === null || prevW === null) {
          prevV = vVal; prevW = wVal;
          outLines.push(leadingWS + tokens.join(" ") + rotQtySuffix);
          continue;
        }
        const dV = vVal - prevV, dW = wVal - prevW;
        segmentDistance = Math.sqrt(dV * dV + dW * dW);
        prevV = vVal; prevW = wVal;
      } else if (hasXYZ) {
        // FileMaker: segmentDistance = Sqrt((ΔX)² + (ΔY)² + (ΔZ)²); missing axis = 0
        if (prevXYZ === null) {
          prevXYZ = { X: 0, Y: 0, Z: 0 };
          for (const a of xyzAxes) prevXYZ[a.letter] = a.val;
          prevHadX = xIdx >= 0; prevHadY = yIdx >= 0; prevHadZ = zIdx >= 0;
          insertAfterIdx = Math.max(...xyzAxes.map(a => a.idx));
          // First point: no D, rotQty with no value (same as FileMaker when lineCount is 1)
          outLines.push(leadingWS + tokens.join(" ") + rotQtySuffix);
          continue;
        }
        // FileMaker: missing axis = 0 in distance (cleared each line). So last = prev had ? prevVal : 0, cur = this line has ? val : 0
        const lastX = prevHadX ? prevXYZ.X : 0, lastY = prevHadY ? prevXYZ.Y : 0, lastZ = prevHadZ ? prevXYZ.Z : 0;
        const curX = (xIdx >= 0 && Number.isFinite(xVal)) ? xVal : 0;
        const curY = (yIdx >= 0 && Number.isFinite(yVal)) ? yVal : 0;
        const curZ = (zIdx >= 0 && Number.isFinite(zVal)) ? zVal : 0;
        const dx = curX - lastX, dy = curY - lastY, dz = curZ - lastZ;
        segmentDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);
        if (xVal != null && Number.isFinite(xVal)) prevXYZ.X = xVal;
        if (yVal != null && Number.isFinite(yVal)) prevXYZ.Y = yVal;
        if (zVal != null && Number.isFinite(zVal)) prevXYZ.Z = zVal;
        prevHadX = xIdx >= 0; prevHadY = yIdx >= 0; prevHadZ = zIdx >= 0;
        insertAfterIdx = Math.max(...xyzAxes.map(a => a.idx));
      }

      if (!useVW && !hasXYZ) {
        outLines.push(rawLine);
        continue;
      }

      // Compute rotQty and D (same for VW and XYZ)
      const rotQty = Math.round((segmentDistance / safePassWidth) * 1e6) / 1e6;
      const deltaDeg = rotQty * 360;
      cumDeg += deltaDeg;
      const D = opts.startD + cumDeg;
      lastD = D;

      // Keep only G-code-like tokens (letter + number) so stray bare numbers from input don't appear in output
      const tokensOut = tokens.filter(t => /^[A-Za-z][-+]?\d*\.?\d*(?:[eE][-+]?\d+)?$/i.test(t) || /^[;:]/.test(t));
      for (let i = tokensOut.length - 1; i >= 0; i--) {
        if (/^D[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?$/i.test(tokensOut[i])) tokensOut.splice(i, 1);
      }
      const Dtok = "D" + formatFixed(D, 5);
      // Insert D after the last position axis (W for VW; rightmost of X,Y,Z,A for XYZ)
      let insertPos = insertAfterIdx + 1;
      let dIdxNow = -1;
      const reAxis = useVW ? /^W[-+]?\d/i : /^[XYZA][-+]?\d/i;
      for (let i = 0; i < tokensOut.length; i++) {
        if (reAxis.test(tokensOut[i])) dIdxNow = i;
      }
      if (dIdxNow >= 0) insertPos = dIdxNow + 1;
      tokensOut.splice(insertPos, 0, Dtok);

      let rotTxt = formatFixed(rotQty, 6);
      if (rotFmt === "semicolon" && rotTxt.startsWith("0.")) rotTxt = rotTxt.slice(1);
      if (rotFmt === "semicolon" && rotTxt.startsWith("-0.")) rotTxt = "-" + rotTxt.slice(2);
      outLines.push(leadingWS + tokensOut.join(" ") + rotQtySuffix + rotTxt);
    }

    return { text: outLines.join("\n"), finalLathePosition: lastD };
  }

  function setStatus(msg) {
    $("status").textContent = msg || "";
    if (msg) setTimeout(() => { $("status").textContent = ""; }, 2500);
  }

  function doConvert() {
    const startD = Number($("startD").value);
    const lineMode = ($("lineMode") && $("lineMode").value) ? $("lineMode").value : "none";
    const nStart = $("nStart") && $("nStart").value !== "" ? Number($("nStart").value) : 10;
    const nInc = $("nInc") && $("nInc").value !== "" ? Number($("nInc").value) : 10;
    const lineNumberType = ($("lineNumberType").value || "N").trim() || "N";
    const rotQtyFormat = ($("rotQtyFormat") && $("rotQtyFormat").value) ? $("rotQtyFormat").value : "semicolon";

    const passW = Number($("passWidth").value);
    const passWidthVal = Number.isFinite(passW) && passW !== 0 ? passW : 0.5;

    const result = convertText($("input").value, {
      startD: Number.isFinite(startD) ? startD : 0,
      lineMode,
      nStart: Number.isFinite(nStart) ? nStart : 10,
      nInc: Number.isFinite(nInc) ? nInc : 10,
      lineNumberType,
      rotQtyFormat,
      passWidth: passWidthVal,
    });

    $("output").value = result.text;
    $("finalLathePosition").value = result.finalLathePosition != null ? String(result.finalLathePosition) : "";
    setStatus("Converted.");
  }

  $("btnConvert").addEventListener("click", doConvert);

  // FileMaker: travelSpeedF = Round(passWidth * desiredSurfaceSpeed / (partDiameter*Pi), 0)
  function updateTravelSpeedF() {
    const partD = Number($("partDiameter").value);
    const dSpeed = Number($("desiredSurfaceSpeed").value);
    const pWidth = Number($("passWidth").value);
    if (Number.isFinite(partD) && partD > 0 && Number.isFinite(dSpeed) && Number.isFinite(pWidth) && pWidth > 0) {
      const f = Math.round((pWidth * dSpeed) / (partD * Math.PI));
      $("travelSpeedF").value = String(f);
    }
  }
  ["partDiameter", "desiredSurfaceSpeed", "passWidth"].forEach(id => {
    $(id).addEventListener("input", updateTravelSpeedF);
  });
  updateTravelSpeedF();

  $("btnCopy").addEventListener("click", async () => {
    try {
      await navigator.clipboard.writeText($("output").value || "");
      setStatus("Copied to clipboard.");
    } catch (e) {
      // Fallback
      $("output").focus();
      $("output").select();
      document.execCommand("copy");
      setStatus("Copied (fallback).");
    }
  });

  $("btnDownload").addEventListener("click", () => {
    const content = $("output").value || "";
    const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "converted.nc";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    setStatus("Download started.");
  });

})();
</script>
</body>
</html>
